# 버블정렬

## 학습목표
- 데이터를 정렬하는 방법 중 하나인 버블정렬에 대해서 알아본다.
- 버블 정렬의 장단점에 대해서 알아본다.

## 핵심개념
- 버블정렬
- 배열

## 버블정렬
정렬되지 않은 리스트를 탐색하는 것 보다 정렬된 상태에서 탐색하여 원하는 값을 찾아주는 것이 훨씬 더 효과적일 것이다.
<br>
이러한 정렬 알고리즘이 여러개 있는데 오늘은 버블정렬에 대해서 알아볼 것이다. <br>
버블정렬은 두개의 인접한 값을 비교하면서 위치를 교환하는 방식으로 정렬하는 방법을 말한다. 마지막에 있는 값이 거품처럼 솟아오른다고 해서 버블정렬이라고 한다. <br>
버블정렬은 간단하지만 단 하나의 요소를 정렬하기 위해서 너무 많이 교환하는 낭비가 발생할 수 도있다.

## 실행
버블정렬은 리스트안에 들어있는 두개의 인접한 수를 비교하고 순서가 맞지않으면 두개의 수의 위치를 바꿔준다. 버블정렬의 의사코드는 아래와 같다.
<br>
- 배열 5, 1, 6, 2, 4, 3
1. 제일 먼저 배열안에 있는 5와 1을 비교해준다. 1이 더 작기때문에 교환
2. 그 다음은 5랑 6을 비교해주고 5가 더 작기때문에 그대로 둔다.
3. 6과 2를 비교해주고 2가 더 작기때문에 위치를 바꿔준다. 계속 같은 방식으로 숫자들의 위치를 바꾸어 준다.

이렇게 된다면 n개의 원소에 대해서 버블정렬은 한번 수행할때마다 n번째의 원소가 자리를 찾게될 것이고 운이없다면 n-1번 실행해야될 수도있다. 

## 느낀점
- 버블정렬의 유래와 원리에대해서 정확히 알게되었다.
- 정렬을 보면서 즐거움을 느꼈다. 지루할줄알았는데 전혀 지루하지 않았다.

## 생각해보기
Q. 버블 정렬이 효율적인 경우는 어떤 경우인가요? 반대로 어떤 경우에 비효율적이게 될까요?

A. 버블정렬이 효율적일때는 n번째 원소를 제외하고 전부다 정렬이 되어있는 경우이거나, n번째 원소가 n-1 위치에 있고 그 외에는 전부 정렬이되어있는 경우일 것 같다.

Q. 버블 정렬을 이용하여 4, 30, 49, 11, 5 를 정렬해 봅시다.

## 코드
```python
# 버블정렬
# 파이썬
list = [4, 30, 49, 11, 5]

for i in range(len(list)-1, 0, -1): # lne(list)-1 부터 0까지 -1씩하면서
    # i가 4이면 4번 반복, i가 3이면 3번 반복
    for j in range(i) :
        if list[j] > list[j+1] :
            list[j], list[j + 1] = list[j + 1], list[j]
    
print(list)
```