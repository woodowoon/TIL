# 시간복잡도

## 학습목표
- 다양한 정렬과 탐색 방법의 시간복잡도를 비교해보자
- 알고리즘의 효율성이 프로그램에 어떤 영향을 미치는지 생각해보자

## 핵심단어
- 시간 복잡도
- Big-O 표기법
- Big Ω

## 시간복잡도
**시간복잡도** 란 알고리즘을 수행할 때 걸리는 시간을 기준으로 효율성을 분석하는 것이다. 시간의 효율성이라는 말은 결국 알고리즘에서 비교와 교환이 얼마나 일어나는가, 에 대한 내용이고 효율적이다 라는 말은 연산자의 처리 횟수가 적다는 뜻이다. <br>
따라서, 시간복잡도가 낮을수록 연산자의 사용횟수가 적을수록 효율성이 높은 알고리즘이 된다.

## Big-O 표기법
Big-O 표기법은 컴퓨터 과학에서 대략을 나타내는 공식적인 개념으로 최악의 경우에 대한 시간복잡도를 나타내는 표현이다. <br>
선형탐색은 비교적 간단한데 찾는 값이 배열의 맨 끝에 있는 최악의 경우에는 n번의 단계를 거치면 되고 이 개념을 O(n) 이라고 표현한다.
<br>
<br>
버블정렬에서는 인접한 자료와 상을 이루어 비교하기 때문에, n개의 자료를 갖는 배열은 n-1 쌍을 비교한다. 전체 비교횟수는 n<sup>2</sup>/2 - n/2 이다. 시간복잡도는 무한으로 다가가면 + n + 1은 무의미한 숫가 되므로 지수가 가장 큰 값 빼고는 없애준다.
시간복잡도는 O(n<sup>2</sup>) 이다.
<br>
<br>
선택정렬은 가장 작은 값을 찾아 제 자리를 찾아준다. n개의 자료가 있다면 첫번째 자료와 나머지 n-1 개의 자료 중 가장 작은 값을 비교해 교환해주어야 한다.
n-1개의 자료중 가장 작은 값을 찾기 위해서는 n-1번 비교를 해야하고 결국 시간복잡도는 버블정렬과 같이 O(n<sup>2</sup>) 이다.
<br>
<br>
삽입정렬은 n개의 자료가 있다면 첫번째 자료는 정렬되었다고 생각하고, n-1 개의 자료 중 첫번째 자료와 정렬된 자료를 비교한다. 이때 정렬된 자료는 1개이기때문에, 비교횟수는 1이고 정렬되지 않은 부분에 1개의 자료가 남게되면, 정렬된 자료 수 n-1개 만큼 비교가 필요하다. 따라서 시간 복잡도는 O(n<sup>2</sup>) 이라고 표현될 수 있다.

![image](https://user-images.githubusercontent.com/67787525/190584225-c0cda2b2-a10a-4624-84f3-3153125dd35f.png)

## Big Ω 표기법
Big-O랑 비슷하지만 다르다. Big-O는 최악의 상황의 표기법이었지만 Big Ω 최선의 경우를 나타내준다.
<br>
<br>
선형탐색은 가장 먼저 자료를 찾아낼 수 있는 경우가 있다. 그렇기때문에 그 경우는 Ω(1) 이라고 나타낸다.
<br>
<br>
버블정렬은 이미 정렬된 정렬을 버블정렬을 한다고 생각을 해보자 그것이 가장 최선의 방법이다. 하지만 버블정렬은 정렬되었다는 사실을 모른다. 그렇기 때문에 Ω (n) 번이라고 할 수 있다.
<br>
<br>
선택정렬은 역시 정렬되었다는 사실을 모르기 때문에 최솟값을 계속 찾아줘야 하기 때문에 Ω(n<sup>2</sup>) 라고 할 수 있다.
<br>
<br>
삽입정렬은 정렬되지 않은 부분에서 정렬된 부분으로 옮길때 정렬된 부분의 가장 큰 수만 비교하면 되므로 Ω(n) 이다.

## 생각해보기
Q. 프로그램이 소비하는 자원을 측정하는 방법에는 어떤 것이 있을까요?

A. 백준 알고리즘을 풀때면 시간과 메모리가 나오는데 프로그램이 소비하는 자원이라고 볼 수 있다. 그렇지만 시간은 빠를 수록 좋다곤 하지만 메모리는 조금 회의적이다. 메모리를 굉장히 적게쓰기위해 따로 메모리를 빼서 써야되는 상황에서까지 메모리를 쓰지 않으면 가독성이 떨어지기 때문이다.

Q. 우리가 컴퓨터 프로그래머로써 어떤 코드를 작성하기 전에 어떻게 시간 복잡도를 분석할 수 있을까요?

A. 몇번비교하는지 확인하고 for을 몇번쓸것인지 생각해본다..?

